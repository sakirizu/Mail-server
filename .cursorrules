# Cursor AI Rules for SMAIL (SSM Mail System)

## 📚 必須参照ドキュメント

コーディング中は以下のドキュメントを**常に参照**してください：

1. **README.md** - 要件定義書（機能要件、進捗状況）
2. **CLAUDE.md** - AI向け技術仕様書（実装詳細、アーキテクチャ）

---

## 🔄 ドキュメント自動更新ルール

ユーザーが**「更新」**とだけ入力した場合、以下の処理を自動実行してください：

1. **コードベース全体をスキャン**: 前回の更新以降の変更を検出
2. **変更内容の自動分析**: 新規・修正・削除ファイルの特定
3. **自動ドキュメント更新**:
   - `README.md`: 機能の実装状況、進捗を更新
   - `CLAUDE.md`: 技術仕様、API、DBスキーマの変更を反映
4. **更新内容の要約表示**: ユーザーに変更内容を報告

---

## 🎯 コーディング規約

### JavaScript / React Native

#### 1. コンポーネント
- **関数コンポーネント**: `export function ComponentName() {}` 形式を使用
- **Hooks**: 状態管理には `useState`, `useEffect` を使用

```javascript
// ✅ Good
export function MailItem({ mail, onPress }) {
  return (
    <TouchableOpacity onPress={onPress}>
      <Text>{mail.subject}</Text>
    </TouchableOpacity>
  );
}
```

#### 2. スタイリング
- **StyleSheet.create()** を使用してスタイルを定義
- **インラインスタイル** は避ける

```javascript
// ✅ Good
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
});
```

#### 3. API通信
- **fetch** または **axios** を使用
- **async/await** でPromise処理
- エラーハンドリングは **try/catch** で

```javascript
// ✅ Good
async function fetchMails(folder) {
  try {
    const response = await fetch(`/api/mails/${folder}`);
    return await response.json();
  } catch (error) {
    console.error('Error fetching mails:', error);
    throw error;
  }
}
```

### Node.js / Express (Backend)

#### 1. ルートハンドラ
- **async/await** を使用
- エラーは適切なステータスコードで返す

```javascript
// ✅ Good
app.get('/api/mails/:folder', auth, async (req, res) => {
  try {
    const mails = await mailService.getByFolder(req.params.folder);
    res.json({ success: true, mails });
  } catch (error) {
    res.status(500).json({ error: 'Server error' });
  }
});
```

#### 2. ミドルウェア
- 認証は `auth` ミドルウェアを使用
- JWT検証を必ず行う

### 命名規則

| 種類 | 規則 | 例 |
|------|------|-----|
| ファイル名 | camelCase | `mailService.js` |
| コンポーネント | PascalCase | `MailItem` |
| 関数・変数 | camelCase | `fetchMails` |
| 定数 | UPPER_SNAKE_CASE | `JWT_SECRET` |

---

## 🔐 セキュリティチェックリスト

1. **認証・認可**:
   - 保護されたルートやAPIでは必ず `auth` ミドルウェアを使用
   - 2FA対応エンドポイントでは2FA検証を確認

2. **入力検証**:
   - ユーザー入力は必ずサーバーサイドで検証
   - SQLインジェクション対策（パラメータ化クエリ使用）

3. **機密情報**:
   - APIキーやシークレットは `.env` ファイルで管理
   - クライアントサイドに機密情報を露出させない

---

## 🛡️ フィッシング検知機能

### データソース
- **PhishTank**: 国際的なフィッシングURLデータベース
- **JPCERT/CC**: https://github.com/JPCERTCC/phishurl-list

### 検出ロジック
1. **既知URLマッチング**: データベースとの照合
2. **類似URL検出**: Levenshtein距離による公式サイト類似判定
3. **キーワード分析**: 危険キーワードの検出
4. **危険度スコア**: 0-100%の信頼度を算出

---

## 💬 コミットメッセージ規約

```
<type>(<scope>): <subject>

<body>
```

| type | 説明 |
|------|------|
| `feat` | 新機能 |
| `fix` | バグ修正 |
| `docs` | ドキュメント変更 |
| `style` | コードスタイル（フォーマット） |
| `refactor` | リファクタリング |
| `test` | テスト追加・修正 |
| `chore` | ビルド・ツール設定 |

例:
```
feat(phishing): JPCERT/CC フィッシングURLリストを統合

- 日次更新機能を追加
- 類似URL検出アルゴリズムを実装
```

---

## 📊 進捗管理

### 実装状況の確認

「更新」コマンド実行時に以下を確認：

1. `src/screens/` - 画面コンポーネント
2. `src/components/` - UIコンポーネント
3. `backend/server.js` - APIエンドポイント
4. `backend/phishing-detector/` - フィッシング検知

### 機能状態の判定

| 状態 | 条件 |
|------|------|
| ✅ 完了 | コード・APIが存在し動作確認済み |
| 🔄 進行中 | コードは存在するがTODOあり |
| ⬜ 未着手 | 対応するコード・APIなし |

---

## 🚀 開発フロー

1. **機能開発前**: README.mdで要件確認
2. **実装中**: CLAUDE.mdで技術仕様参照
3. **実装後**: 「更新」でドキュメント同期
4. **コミット**: 規約に従ったメッセージ
